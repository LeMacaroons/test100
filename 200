healthchecks/
  deploy-healthchecks.yml
  templates/
    healthcheck_runner.sh.j2
    targets_node.txt.j2
    targets_lb.txt.j2
    healthcheck-node.service.j2
    healthcheck-node.timer.j2
    healthcheck-lb.service.j2
    healthcheck-lb.timer.j2


Put all node-level endpoints here:
# service  node  url
sss rww01 https://server1.ggc.local:8810/sss/api/v1/health
sss rww02 https://server2.ggc.local:8810/sss/api/v1/health

# Add more services and nodes below:
# abc rww01 https://server1.ggc.local:8820/abc/api/v1/health
# abc rww02 https://server2.ggc.local:8820/abc/api/v1/health


Put LB/VIP endpoints here:
# service  url
sss https://sss-vip.ggc.local/sss/api/v1/health

# abc https://abc-vip.ggc.local/abc/api/v1/health

Step2:
##############
healthchecks/deploy-healthchecks.yml
---
- name: Deploy API healthchecks (systemd timers, separate logs)
  hosts: utility_servers
  become: true

  vars:
    # Tag written into events
    env_name: prod

    # Log output directory requested
    log_dir: /logs/ggg/health
    node_log: /logs/ggg/health/node_health.jsonl
    lb_log: /logs/ggg/health/lb_health.jsonl

    # Where target files live on the server
    cfg_dir: /etc/healthchecks
    node_targets_file: /etc/healthchecks/targets_node.txt
    lb_targets_file: /etc/healthchecks/targets_lb.txt

    # curl -k behavior (1 = insecure, 0 = verify TLS)
    insecure_tls: "1"

    # Performance knobs
    node_parallel: 10
    lb_parallel: 5
    max_time: 2
    connect_timeout: 1

    # Schedules
    node_interval_seconds: 60
    lb_interval_seconds: 30
    node_onboot_delay: 30
    lb_onboot_delay: 15
    node_jitter_seconds: 5
    lb_jitter_seconds: 3

  tasks:
    - name: Install required packages
      ansible.builtin.dnf:
        name: [curl, jq]
        state: present

    - name: Create config and log directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: "0755"
      loop:
        - "{{ cfg_dir }}"
        - "{{ log_dir }}"

    - name: Deploy healthcheck runner script
      ansible.builtin.template:
        src: templates/healthcheck_runner.sh.j2
        dest: /usr/local/bin/healthcheck_runner.sh
        owner: root
        group: root
        mode: "0755"

    - name: Deploy NODE targets file
      ansible.builtin.template:
        src: templates/targets_node.txt.j2
        dest: "{{ node_targets_file }}"
        owner: root
        group: root
        mode: "0644"
      tags: [node]

    - name: Deploy LB targets file
      ansible.builtin.template:
        src: templates/targets_lb.txt.j2
        dest: "{{ lb_targets_file }}"
        owner: root
        group: root
        mode: "0644"
      tags: [lb]

    - name: Deploy systemd unit files (node + lb)
      ansible.builtin.template:
        src: "templates/{{ item }}.j2"
        dest: "/etc/systemd/system/{{ item }}"
        owner: root
        group: root
        mode: "0644"
      loop:
        - healthcheck-node.service
        - healthcheck-node.timer
        - healthcheck-lb.service
        - healthcheck-lb.timer

    - name: Reload systemd
      ansible.builtin.systemd:
        daemon_reload: true

    - name: Enable and start node timer
      ansible.builtin.systemd:
        name: healthcheck-node.timer
        enabled: true
        state: started
      tags: [node]

    - name: Enable and start lb timer
      ansible.builtin.systemd:
        name: healthcheck-lb.timer
        enabled: true
        state: started
      tags: [lb]

#########################
Step3: 

healthchecks/templates/healthcheck_runner.sh.j2
#!/usr/bin/env bash
set -euo pipefail

CHECK_TYPE="${1:?missing check_type (node|lb)}"
TARGETS_FILE="${2:?missing targets_file}"
OUT_FILE="${3:?missing output_jsonl}"

PARALLEL="${PARALLEL:-10}"
MAX_TIME="${MAX_TIME:-2}"
CONNECT_TIMEOUT="${CONNECT_TIMEOUT:-1}"
INSECURE_TLS="${INSECURE_TLS:-1}"
ENV_NAME="${ENV_NAME:-}"

PROBE_HOST="$(hostname)"
mkdir -p "$(dirname "$OUT_FILE")"

curl_tls_flags=()
if [[ "$INSECURE_TLS" == "1" ]]; then
  curl_tls_flags+=("-k")
fi

check_one() {
  local service="$1"
  local node="$2"
  local url="$3"

  local ts start_ns end_ns lat_ms resp http_code body
  ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  start_ns="$(date +%s%N)"

  resp="$(curl -s "${curl_tls_flags[@]}" \
      --connect-timeout "$CONNECT_TIMEOUT" \
      --max-time "$MAX_TIME" \
      -w "\n%{http_code}\n" \
      "$url" || true)"

  http_code="$(echo "$resp" | tail -n 1)"
  body="$(echo "$resp" | sed '$d')"

  end_ns="$(date +%s%N)"
  lat_ms=$(( (end_ns - start_ns) / 1000000 ))

  local status="fail"
  local error=""
  local app_version="" app_node_name="" uptime="" server_date=""

  if [[ "$http_code" != "200" ]]; then
    error="non-200"
  else
    if echo "$body" | jq -e . >/dev/null 2>&1; then
      app_version="$(echo "$body" | jq -r '.AppVersion // ""')"
      app_node_name="$(echo "$body" | jq -r '.AppNodeName // ""')"
      uptime="$(echo "$body" | jq -r '.Uptime // ""')"
      server_date="$(echo "$body" | jq -r '.Date // ""')"

      # For node checks, your sample API includes AppNodeName; use it as validity gate.
      if [[ "$CHECK_TYPE" == "node" && -z "$app_node_name" ]]; then
        error="missing_AppNodeName"
      else
        status="pass"
      fi
    else
      error="invalid_json"
    fi
  fi

  jq -cn \
    --arg ts "$ts" \
    --arg env "$ENV_NAME" \
    --arg check_type "$CHECK_TYPE" \
    --arg service "$service" \
    --arg node "$node" \
    --arg url "$url" \
    --arg probe_host "$PROBE_HOST" \
    --arg status "$status" \
    --arg error "$error" \
    --arg app_version "$app_version" \
    --arg app_node_name "$app_node_name" \
    --arg uptime "$uptime" \
    --arg server_date "$server_date" \
    --argjson http_code "${http_code:-0}" \
    --argjson latency_ms "$lat_ms" \
    '{
      ts:$ts,
      env:$env,
      check_type:$check_type,
      service:$service,
      node:$node,
      url:$url,
      probe_host:$probe_host,
      status:$status,
      http_code:$http_code,
      latency_ms:$latency_ms
    }
    + (if $error != "" then {error:$error} else {} end)
    + (if $app_version != "" then {app_version:$app_version} else {} end)
    + (if $app_node_name != "" then {app_node_name:$app_node_name} else {} end)
    + (if $uptime != "" then {uptime:$uptime} else {} end)
    + (if $server_date != "" then {server_date:$server_date} else {} end)
    '
}

export -f check_one
export CHECK_TYPE

tmpfile="$(mktemp)"
trap 'rm -f "$tmpfile"' EXIT

# Normalize targets into: service node url
# node file: service node url
# lb file:   service url -> node="vip"
awk '
  /^[[:space:]]*($|#)/ { next }
  NF==2 { print $1, "vip", $2; next }
  NF>=3 { print $1, $2, $3; next }
' "$TARGETS_FILE" \
| xargs -n 3 -P "$PARALLEL" bash -c 'check_one "$1" "$2" "$3"' _ \
> "$tmpfile"

cat "$tmpfile" >> "$OUT_FILE"


Step 4 â€” Add systemd unit templates
healthchecks/templates/healthcheck-node.service.j2

[Unit]
Description=API node health checks

[Service]
Type=oneshot
Environment=ENV_NAME={{ env_name }}
Environment=PARALLEL={{ node_parallel }}
Environment=MAX_TIME={{ max_time }}
Environment=CONNECT_TIMEOUT={{ connect_timeout }}
Environment=INSECURE_TLS={{ insecure_tls }}
ExecStart=/usr/local/bin/healthcheck_runner.sh node {{ node_targets_file }} {{ node_log }}


healthchecks/templates/healthcheck-node.timer.j2
[Unit]
Description=Run API node health checks every {{ node_interval_seconds }} seconds

[Timer]
OnBootSec={{ node_onboot_delay }}s
OnUnitActiveSec={{ node_interval_seconds }}s
RandomizedDelaySec={{ node_jitter_seconds }}s
Unit=healthcheck-node.service

[Install]
WantedBy=timers.target


healthchecks/templates/healthcheck-lb.service.j2
[Unit]
Description=API LB health checks

[Service]
Type=oneshot
Environment=ENV_NAME={{ env_name }}
Environment=PARALLEL={{ lb_parallel }}
Environment=MAX_TIME={{ max_time }}
Environment=CONNECT_TIMEOUT={{ connect_timeout }}
Environment=INSECURE_TLS={{ insecure_tls }}
ExecStart=/usr/local/bin/healthcheck_runner.sh lb {{ lb_targets_file }} {{ lb_log }}

####
healthchecks/templates/healthcheck-lb.timer.j2
###
[Unit]
Description=Run API LB health checks every {{ lb_interval_seconds }} seconds

[Timer]
OnBootSec={{ lb_onboot_delay }}s
OnUnitActiveSec={{ lb_interval_seconds }}s
RandomizedDelaySec={{ lb_jitter_seconds }}s
Unit=healthcheck-lb.service

[Install]
WantedBy=timers.target


