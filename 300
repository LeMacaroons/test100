#!/usr/bin/env bash
set -euo pipefail

CHECK_TYPE="${1:?missing check_type (node|lb)}"
TARGETS_FILE="${2:?missing targets_file}"
OUT_FILE="${3:?missing output_jsonl}"

PARALLEL="${PARALLEL:-10}"
MAX_TIME="${MAX_TIME:-2}"
CONNECT_TIMEOUT="${CONNECT_TIMEOUT:-1}"
INSECURE_TLS="${INSECURE_TLS:-1}"
ENV_NAME="${ENV_NAME:-}"

mkdir -p "$(dirname "$OUT_FILE")"

check_one() {
  local service="$1"
  local node="$2"
  local url="$3"

  local ts start_ns end_ns lat_ms
  local resp http_code body
  local status="fail"
  local error=""
  local app_version="" app_node_name="" uptime="" server_date=""
  local probe_host curl_rc

  ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  start_ns="$(date +%s%N)"
  probe_host="$(hostname)"

  # IMPORTANT: Build TLS flags inside the function (works under xargs subshell)
  local tls_flags=()
  if [[ "${INSECURE_TLS}" == "1" ]]; then
    tls_flags+=("-k")
  fi

  # Run curl without killing the script on non-zero exit (we want curl_rc + logging)
  curl_rc=0
  set +e
  resp="$(
    curl -s "${tls_flags[@]}" \
      --connect-timeout "$CONNECT_TIMEOUT" \
      --max-time "$MAX_TIME" \
      -w $'\n%{http_code}' \
      "$url"
  )"
  curl_rc=$?
  set -e

  # Parse: last line is http_code; everything before is body
  http_code="$(printf '%s' "$resp" | tail -n 1)"
  body="$(printf '%s' "$resp" | sed '$d')"

  # If parsing yields empty (or curl failed before writing code), force "000"
  if [[ -z "${http_code}" ]]; then
    http_code="000"
  fi

  end_ns="$(date +%s%N)"
  lat_ms=$(( (end_ns - start_ns) / 1000000 ))

  # Decide pass/fail + error
  if [[ "$curl_rc" -ne 0 ]]; then
    error="curl_error"
  elif [[ "$http_code" != "200" ]]; then
    error="non-200"
  else
    if echo "$body" | jq -e . >/dev/null 2>&1; then
      app_version="$(echo "$body" | jq -r '.AppVersion // ""')"
      app_node_name="$(echo "$body" | jq -r '.AppNodeName // ""')"
      uptime="$(echo "$body" | jq -r '.Uptime // ""')"
      server_date="$(echo "$body" | jq -r '.Date // ""')"

      # For node checks, require AppNodeName if you want to ensure you hit a real node
      if [[ "$CHECK_TYPE" == "node" && -z "$app_node_name" ]]; then
        error="missing_AppNodeName"
      else
        status="pass"
      fi
    else
      error="invalid_json"
    fi
  fi

  jq -cn \
    --arg ts "$ts" \
    --arg env "$ENV_NAME" \
    --arg check_type "$CHECK_TYPE" \
    --arg service "$service" \
    --arg node "$node" \
    --arg url "$url" \
    --arg probe_host "$probe_host" \
    --arg status "$status" \
    --arg error "$error" \
    --arg http_code "$http_code" \
    --argjson curl_rc "$curl_rc" \
    --argjson latency_ms "$lat_ms" \
    --arg app_version "$app_version" \
    --arg app_node_name "$app_node_name" \
    --arg uptime "$uptime" \
    --arg server_date "$server_date" \
    '{
      ts:$ts,
      env:$env,
      check_type:$check_type,
      service:$service,
      node:$node,
      url:$url,
      probe_host:$probe_host,
      status:$status,
      http_code:$http_code,
      latency_ms:$latency_ms
    }
    + (if $error != "" then {error:$error} else {} end)
    + (if $curl_rc != 0 then {curl_rc:$curl_rc} else {} end)
    + (if $app_version != "" then {app_version:$app_version} else {} end)
    + (if $app_node_name != "" then {app_node_name:$app_node_name} else {} end)
    + (if $uptime != "" then {uptime:$uptime} else {} end)
    + (if $server_date != "" then {server_date:$server_date} else {} end)
    '
}

export -f check_one
export CHECK_TYPE

tmpfile="$(mktemp)"
trap 'rm -f "$tmpfile"' EXIT

# Normalize targets into: service node url
# node file: service node url
# lb file:   service url -> node="vip"
awk '
  /^[[:space:]]*($|#)/ { next }
  NF==2 { print $1, "vip", $2; next }
  NF>=3 { print $1, $2, $3; next }
' "$TARGETS_FILE" \
| xargs -n 3 -P "$PARALLEL" bash -c 'check_one "$1" "$2" "$3"' _ \
> "$tmpfile"

cat "$tmpfile" >> "$OUT_FILE"
